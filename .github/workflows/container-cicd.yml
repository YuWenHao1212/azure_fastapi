name: Container Apps CI/CD

on:
  pull_request:
    branches: [ container ]
    types: [ opened, synchronize, reopened ]
  push:
    branches: [ container ]
  workflow_dispatch:
    inputs:
      debug_mode:
        description: 'Enable debug mode'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  REGISTRY: airesumeadvisorregistry.azurecr.io
  IMAGE_NAME: airesumeadvisor-api
  RESOURCE_GROUP: airesumeadvisorfastapi
  CONTAINER_APP_NAME: airesumeadvisor-api-production
  CONTAINER_APP_ENV: airesumeadvisor-env-production

jobs:
  # Job 1: Run tests on PR
  test:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Create test .env file
      run: |
        cat > .env << EOF
        # Azure OpenAI Configuration
        AZURE_OPENAI_ENDPOINT=${{ secrets.AZURE_OPENAI_ENDPOINT }}
        AZURE_OPENAI_API_KEY=${{ secrets.AZURE_OPENAI_API_KEY }}
        AZURE_OPENAI_GPT4_DEPLOYMENT=gpt-4o-mini
        AZURE_OPENAI_API_VERSION=2024-02-15-preview
        
        # GPT-4.1 mini Japan East
        GPT41_MINI_JAPANEAST_ENDPOINT=${{ secrets.GPT41_MINI_JAPANEAST_ENDPOINT }}
        GPT41_MINI_JAPANEAST_API_KEY=${{ secrets.GPT41_MINI_JAPANEAST_API_KEY }}
        GPT41_MINI_JAPANEAST_DEPLOYMENT=gpt-4-1-mini-japaneast
        
        # Sweden Central Embedding
        EMBEDDING_ENDPOINT=${{ secrets.EMBEDDING_ENDPOINT }}
        EMBEDDING_API_KEY=${{ secrets.EMBEDDING_API_KEY }}
        
        # Database (not used in tests, course search uses postgres_connection.json)
        DATABASE_URL=
        
        # Monitoring (disabled for tests)
        MONITORING_ENABLED=false
        LIGHTWEIGHT_MONITORING_ENABLED=true
        
        # API Security
        API_KEY_HEADER_NAME=X-API-Key
        VALID_API_KEYS=${{ secrets.VALID_API_KEYS }}
        EOF
    
    - name: Run Level 3 tests
      run: |
        chmod +x ./precommit.sh
        ./precommit.sh --level-3 --parallel
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          htmlcov/
          .coverage
          pytest.xml

  # Job 2: Build and push Docker image (only on merge to container branch)
  build-and-push:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Generate build metadata
      id: meta
      run: |
        # 修復 2: 改善 Revision Suffix 生成策略
        # 使用時間戳 + 隨機字符避免衝突，確保長度符合 Container Apps 限制 (10 字符)
        TIMESTAMP=$(date -u +'%Y%m%d-%H%M%S')
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        VERSION_TAG="${TIMESTAMP}-${SHORT_SHA}"
        
        # 生成高唯一性的 revision suffix: 時間戳(6位) + 隨機字符(4位) = 10字符
        MICRO_TIMESTAMP=$(date -u +'%H%M%S')
        RANDOM_SUFFIX=$(openssl rand -hex 2)
        REVISION_SUFFIX="${MICRO_TIMESTAMP}${RANDOM_SUFFIX}"
        
        # 確保 revision suffix 符合 10 字符限制
        REVISION_SUFFIX=$(echo $REVISION_SUFFIX | cut -c1-10)
        
        # Set outputs directly without intermediate variables
        echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
        echo "full_image_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}" >> $GITHUB_OUTPUT
        echo "latest_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
        echo "revision_suffix=${REVISION_SUFFIX}" >> $GITHUB_OUTPUT
        
        # Debug output
        echo "Generated version_tag: ${VERSION_TAG}"
        echo "Generated full_image_tag: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}"
        echo "Generated revision_suffix: ${REVISION_SUFFIX} (length: ${#REVISION_SUFFIX})"
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./deployment/container-apps/Dockerfile
        platforms: linux/amd64
        push: true
        tags: |
          ${{ steps.meta.outputs.full_image_tag }}
          ${{ steps.meta.outputs.latest_tag }}
    
    - name: Create deployment record
      run: |
        echo "Deployment Information" > deployment-info.txt
        echo "=====================" >> deployment-info.txt
        echo "Image Tag: ${{ steps.meta.outputs.version_tag }}" >> deployment-info.txt
        echo "Full Image: ${{ steps.meta.outputs.full_image_tag }}" >> deployment-info.txt
        echo "Commit SHA: ${{ github.sha }}" >> deployment-info.txt
        echo "Commit Message: ${{ github.event.head_commit.message }}" >> deployment-info.txt
        echo "Deployed By: ${{ github.actor }}" >> deployment-info.txt
        echo "Deployment Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> deployment-info.txt
    
    - name: Upload deployment info
      uses: actions/upload-artifact@v4
      with:
        name: deployment-info-${{ steps.meta.outputs.version_tag }}
        path: deployment-info.txt
    
    outputs:
      version_tag: ${{ steps.meta.outputs.version_tag }}
      full_image_tag: ${{ steps.meta.outputs.full_image_tag }}
      revision_suffix: ${{ steps.meta.outputs.revision_suffix }}

  # Job 3: Deploy to Azure Container Apps
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Deploy to Container Apps
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Get outputs from build job
          VERSION_TAG="${{ needs.build-and-push.outputs.version_tag }}"
          FULL_IMAGE="${{ needs.build-and-push.outputs.full_image_tag }}"
          REVISION_SUFFIX="${{ needs.build-and-push.outputs.revision_suffix }}"
          
          # Debug outputs
          echo "Received version_tag: ${VERSION_TAG}"
          echo "Received full_image_tag: ${FULL_IMAGE}"
          echo "Received revision_suffix: ${REVISION_SUFFIX}"
          
          # Validate outputs
          if [ -z "${FULL_IMAGE}" ] || [ "${FULL_IMAGE}" = "null" ]; then
            echo "ERROR: Full image tag is empty or null"
            echo "Reconstructing from version tag..."
            FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}"
          fi
          
          if [ -z "${REVISION_SUFFIX}" ]; then
            echo "WARNING: Revision suffix is empty, generating new one"
            # 使用改善的生成策略
            MICRO_TIMESTAMP=$(date -u +'%H%M%S')
            RANDOM_SUFFIX=$(openssl rand -hex 2)
            REVISION_SUFFIX="${MICRO_TIMESTAMP}${RANDOM_SUFFIX}"
            REVISION_SUFFIX=$(echo $REVISION_SUFFIX | cut -c1-10)
          fi
          
          echo "Final image to deploy: ${FULL_IMAGE}"
          echo "Final revision suffix: ${REVISION_SUFFIX}"
          
          # Update Container App with new image
          echo "Starting Container App update..."
          if [ "${{ github.event.inputs.debug_mode }}" = "true" ]; then
            echo "Debug mode enabled - using verbose output"
            az containerapp update \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --image ${FULL_IMAGE} \
              --revision-suffix ${REVISION_SUFFIX} \
              --debug
          else
            az containerapp update \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --image ${FULL_IMAGE} \
              --revision-suffix ${REVISION_SUFFIX}
          fi
          
          echo "Container App update command completed. Starting deployment verification..."
          
          # 修復 1: 延長等待時間和增加重試機制
          # 延長初始等待時間從 30 秒到 60 秒
          echo "Initial wait for deployment to stabilize (60 seconds)..."
          sleep 60
          
          # 增加最多 3 次的重試檢查機制
          MAX_RETRIES=3
          RETRY_COUNT=0
          DEPLOYMENT_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deployment verification attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            
            # Get the latest revision
            LATEST_REVISION=$(az containerapp revision list \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "[0].name" -o tsv)
            
            echo "Latest revision: $LATEST_REVISION"
            
            # Check revision status
            REVISION_STATUS=$(az containerapp revision show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --revision $LATEST_REVISION \
              --query "properties.runningState" -o tsv)
            
            echo "Revision status: $REVISION_STATUS"
            
            # 對 Deprovisioning 狀態進行特殊處理
            if [ "$REVISION_STATUS" = "Deprovisioning" ]; then
              echo "Revision is in Deprovisioning state, waiting for transition..."
              sleep 30
              continue
            elif [ "$REVISION_STATUS" = "Running" ]; then
              echo "Deployment successful! Revision is in Running state."
              DEPLOYMENT_SUCCESS=true
              break
            elif [ "$REVISION_STATUS" = "Failed" ]; then
              echo "Deployment failed! Revision is in Failed state."
              # 修復 3: 增加失敗診斷資訊
              echo "=== DEPLOYMENT FAILURE DIAGNOSTICS ==="
              echo "Failed revision details:"
              az containerapp revision show \
                --name ${{ env.CONTAINER_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --revision $LATEST_REVISION \
                --output table
              break
            else
              echo "Revision status: $REVISION_STATUS (waiting for Running state)"
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting 30 seconds before next retry..."
              sleep 30
            fi
          done
          
          # 最終檢查
          if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then
            echo "=== COMPREHENSIVE FAILURE DIAGNOSTICS ==="
            
            # 顯示所有 revisions 狀態
            echo "All revisions status:"
            az containerapp revision list \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --output table
            
            # 顯示 Container App 詳細資訊
            echo "Container App details:"
            az containerapp show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --output table
            
            # 嘗試取得應用程式日誌
            echo "Recent application logs:"
            az containerapp logs show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --tail 50 || echo "Unable to retrieve logs"
            
            echo "Deployment failed after $MAX_RETRIES retries!"
            exit 1
          fi
    
    - name: Verify deployment
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # 修復 3: 測試健康檢查端點 (改善版)
          # 取得應用程式 URL
          APP_URL=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "Testing application health at https://$APP_URL/health"
          
          # 增強的重試邏輯，延長等待時間
          MAX_RETRIES=6
          RETRY_COUNT=0
          HEALTH_CHECK_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            
            # 使用更詳細的 curl 檢查
            HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}\nTIME_TOTAL:%{time_total}\n" \
              --max-time 30 --connect-timeout 10 https://$APP_URL/health)
            
            HTTP_CODE=$(echo "$HTTP_RESPONSE" | grep HTTPSTATUS | cut -d: -f2)
            TIME_TOTAL=$(echo "$HTTP_RESPONSE" | grep TIME_TOTAL | cut -d: -f2)
            RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '/HTTPSTATUS:/d' | sed '/TIME_TOTAL:/d')
            
            echo "HTTP Status: $HTTP_CODE, Response Time: ${TIME_TOTAL}s"
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed! Application is running."
              echo "Response body: $RESPONSE_BODY"
              HEALTH_CHECK_SUCCESS=true
              break
            else
              echo "Health check failed with HTTP code: $HTTP_CODE"
              if [ ! -z "$RESPONSE_BODY" ]; then
                echo "Response body: $RESPONSE_BODY"
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Waiting 15 seconds before next retry..."
                sleep 15
              fi
            fi
          done
          
          if [ "$HEALTH_CHECK_SUCCESS" != "true" ]; then
            echo "=== HEALTH CHECK FAILURE DIAGNOSTICS ==="
            echo "Health check failed after $MAX_RETRIES retries!"
            
            # 嘗試基本連接測試
            echo "Testing basic connectivity to $APP_URL..."
            curl -I --max-time 10 https://$APP_URL/ || echo "Basic connectivity test failed"
            
            # 顯示當前 Container App 狀態
            echo "Current Container App status:"
            az containerapp show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "{name:name,state:properties.runningState,fqdn:properties.configuration.ingress.fqdn}" \
              --output table
            
            exit 1
          fi
    
    - name: Create GitHub deployment
      uses: actions/github-script@v7
      with:
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Deployed version ${{ needs.build-and-push.outputs.version_tag }}',
            auto_merge: false,
            required_contexts: []
          });
          
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: deployment.data.id,
            state: 'success',
            environment_url: 'https://airesumeadvisor-api-production.calmisland-ea7fe91e.japaneast.azurecontainerapps.io',
            description: 'Deployment completed successfully'
          });

  # Job 4: Cleanup old images in ACR (runs after successful deployment)
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Cleanup old images
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Keep only the last 5 images
          IMAGES_TO_DELETE=$(az acr repository show-manifests \
            --name airesumeadvisorregistry \
            --repository ${{ env.IMAGE_NAME }} \
            --orderby time_desc \
            --query "[5:].digest" -o tsv)
          
          if [ ! -z "$IMAGES_TO_DELETE" ]; then
            echo "Deleting old images..."
            for DIGEST in $IMAGES_TO_DELETE; do
              echo "Deleting image with digest: $DIGEST"
              az acr repository delete \
                --name airesumeadvisorregistry \
                --image ${{ env.IMAGE_NAME }}@$DIGEST \
                --yes
            done
          else
            echo "No old images to delete"
          fi