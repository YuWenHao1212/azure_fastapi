name: Container Apps CI/CD

on:
  pull_request:
    branches: [ container ]
    types: [ opened, synchronize, reopened ]
  push:
    branches: [ container ]
  workflow_dispatch:

env:
  REGISTRY: airesumeadvisorregistry.azurecr.io
  IMAGE_NAME: airesumeadvisor-api
  RESOURCE_GROUP: airesumeadvisorfastapi
  CONTAINER_APP_NAME: airesumeadvisor-api-production
  CONTAINER_APP_ENV: airesumeadvisor-env-production

jobs:
  # Job 1: Run tests on PR
  test:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Create test .env file
      run: |
        cat > .env << EOF
        # Azure OpenAI Configuration
        AZURE_OPENAI_ENDPOINT=${{ secrets.AZURE_OPENAI_ENDPOINT }}
        AZURE_OPENAI_API_KEY=${{ secrets.AZURE_OPENAI_API_KEY }}
        AZURE_OPENAI_GPT4_DEPLOYMENT=gpt-4o-mini
        AZURE_OPENAI_API_VERSION=2024-02-15-preview
        
        # GPT-4.1 mini Japan East
        GPT41_MINI_JAPANEAST_ENDPOINT=${{ secrets.GPT41_MINI_JAPANEAST_ENDPOINT }}
        GPT41_MINI_JAPANEAST_API_KEY=${{ secrets.GPT41_MINI_JAPANEAST_API_KEY }}
        GPT41_MINI_JAPANEAST_DEPLOYMENT=gpt-4-1-mini-japaneast
        
        # Sweden Central Embedding
        EMBEDDING_ENDPOINT=${{ secrets.EMBEDDING_ENDPOINT }}
        EMBEDDING_API_KEY=${{ secrets.EMBEDDING_API_KEY }}
        
        # Database
        DATABASE_URL=${{ secrets.DATABASE_URL }}
        
        # Monitoring (disabled for tests)
        MONITORING_ENABLED=false
        LIGHTWEIGHT_MONITORING_ENABLED=true
        
        # API Security
        API_KEY_HEADER_NAME=X-API-Key
        VALID_API_KEYS=${{ secrets.VALID_API_KEYS }}
        EOF
    
    - name: Run Level 3 tests
      run: |
        chmod +x ./precommit.sh
        ./precommit.sh --level-3 --parallel
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: |
          htmlcov/
          .coverage
          pytest.xml

  # Job 2: Build and push Docker image (only on merge to container branch)
  build-and-push:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Generate build metadata
      id: meta
      run: |
        # Generate unique tag with timestamp and short SHA
        TIMESTAMP=$(date -u +'%Y%m%d-%H%M%S')
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        VERSION_TAG="${TIMESTAMP}-${SHORT_SHA}"
        
        echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
        echo "full_image_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}" >> $GITHUB_OUTPUT
        echo "latest_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./deployment/container-apps/Dockerfile
        platforms: linux/amd64
        push: true
        tags: |
          ${{ steps.meta.outputs.full_image_tag }}
          ${{ steps.meta.outputs.latest_tag }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
    
    - name: Create deployment record
      run: |
        echo "Deployment Information" > deployment-info.txt
        echo "=====================" >> deployment-info.txt
        echo "Image Tag: ${{ steps.meta.outputs.version_tag }}" >> deployment-info.txt
        echo "Full Image: ${{ steps.meta.outputs.full_image_tag }}" >> deployment-info.txt
        echo "Commit SHA: ${{ github.sha }}" >> deployment-info.txt
        echo "Commit Message: ${{ github.event.head_commit.message }}" >> deployment-info.txt
        echo "Deployed By: ${{ github.actor }}" >> deployment-info.txt
        echo "Deployment Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> deployment-info.txt
    
    - name: Upload deployment info
      uses: actions/upload-artifact@v3
      with:
        name: deployment-info-${{ steps.meta.outputs.version_tag }}
        path: deployment-info.txt
    
    outputs:
      version_tag: ${{ steps.meta.outputs.version_tag }}
      full_image_tag: ${{ steps.meta.outputs.full_image_tag }}

  # Job 3: Deploy to Azure Container Apps
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Deploy to Container Apps
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Update Container App with new image
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ needs.build-and-push.outputs.full_image_tag }} \
            --revision-suffix ${{ needs.build-and-push.outputs.version_tag }}
          
          # Wait for deployment to complete
          echo "Waiting for deployment to complete..."
          sleep 30
          
          # Get the latest revision
          LATEST_REVISION=$(az containerapp revision list \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[0].name" -o tsv)
          
          echo "Latest revision: $LATEST_REVISION"
          
          # Check revision status
          REVISION_STATUS=$(az containerapp revision show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --revision $LATEST_REVISION \
            --query "properties.runningState" -o tsv)
          
          echo "Revision status: $REVISION_STATUS"
          
          if [ "$REVISION_STATUS" != "Running" ]; then
            echo "Deployment failed! Revision is not in Running state."
            exit 1
          fi
    
    - name: Verify deployment
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Test the health endpoint
          APP_URL=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "Testing application health at https://$APP_URL/health"
          
          # Retry logic for health check
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://$APP_URL/health)
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed! Application is running."
              break
            else
              echo "Health check failed with HTTP code: $HTTP_CODE. Retrying..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              sleep 10
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Health check failed after $MAX_RETRIES retries!"
            exit 1
          fi
    
    - name: Create GitHub deployment
      uses: actions/github-script@v7
      with:
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Deployed version ${{ needs.build-and-push.outputs.version_tag }}',
            auto_merge: false,
            required_contexts: []
          });
          
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: deployment.data.id,
            state: 'success',
            environment_url: 'https://airesumeadvisor-api-production.yellowpond-a96deff7.japaneast.azurecontainerapps.io',
            description: 'Deployment completed successfully'
          });

  # Job 4: Cleanup old images in ACR (runs after successful deployment)
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/container'
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Cleanup old images
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Keep only the last 5 images
          IMAGES_TO_DELETE=$(az acr repository show-manifests \
            --name airesumeadvisorregistry \
            --repository ${{ env.IMAGE_NAME }} \
            --orderby time_desc \
            --query "[5:].digest" -o tsv)
          
          if [ ! -z "$IMAGES_TO_DELETE" ]; then
            echo "Deleting old images..."
            for DIGEST in $IMAGES_TO_DELETE; do
              echo "Deleting image with digest: $DIGEST"
              az acr repository delete \
                --name airesumeadvisorregistry \
                --image ${{ env.IMAGE_NAME }}@$DIGEST \
                --yes
            done
          else
            echo "No old images to delete"
          fi