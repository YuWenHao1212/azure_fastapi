<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinyMCE Rich Editor Debug Tool for Bubble.io</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .debug-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .header p {
            margin: 5px 0 0 0;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #fafafa;
        }
        
        .section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5a67d8;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
        }
        
        .btn-info {
            background: #4299e1;
            color: white;
        }
        
        .btn-info:hover {
            background: #3182ce;
        }
        
        .btn-warning {
            background: #ed8936;
            color: white;
        }
        
        .btn-warning:hover {
            background: #dd6b20;
        }
        
        .output-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status.found {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .status.not-found {
            background: #fed7d7;
            color: #742a2a;
        }
        
        .info-box {
            background: #e6fffa;
            border-left: 4px solid #38b2ac;
            padding: 15px;
            margin: 15px 0;
        }
        
        .info-box h4 {
            margin-top: 0;
            color: #234e52;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .highlight {
            background: #ffd700;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <div class="header">
            <h1>ğŸ” TinyMCE Debug Tool</h1>
            <p>å°ˆç‚º Bubble.io Rich Text Editor è¨­è¨ˆçš„é™¤éŒ¯å·¥å…·</p>
        </div>
        
        <div class="content">
            <!-- åŸºæœ¬æª¢æ¸¬ -->
            <div class="section">
                <h3>ğŸ” åŸºæœ¬æª¢æ¸¬</h3>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="detectTinyMCE()">æª¢æ¸¬ TinyMCE</button>
                    <button class="btn btn-info" onclick="listAllEditors()">åˆ—å‡ºæ‰€æœ‰ç·¨è¼¯å™¨</button>
                    <button class="btn btn-success" onclick="getEditorContent()">ç²å–ç·¨è¼¯å™¨å…§å®¹</button>
                    <button class="btn btn-warning" onclick="getEditorHTML()">ç²å– HTML åŸå§‹ç¢¼</button>
                    <button class="btn btn-info" onclick="forceInitEditor()">å¼·åˆ¶åˆå§‹åŒ–</button>
                    <button class="btn btn-warning" onclick="getIframeContent()">æª¢æŸ¥ iframe å…§å®¹</button>
                </div>
                <div id="basicDetection" class="output-box"></div>
            </div>
            
            <!-- å…§å®¹åˆ†æ -->
            <div class="section">
                <h3>ğŸ“ å…§å®¹åˆ†æ</h3>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="analyzeContent()">åˆ†æå…§å®¹çµæ§‹</button>
                    <button class="btn btn-info" onclick="findMarkers()">æŸ¥æ‰¾è¦–è¦ºæ¨™è¨˜</button>
                    <button class="btn btn-success" onclick="countElements()">çµ±è¨ˆå…ƒç´ </button>
                    <button class="btn btn-warning" onclick="validateHTML()">é©—è­‰ HTML</button>
                </div>
                <div id="contentAnalysis" class="output-box"></div>
            </div>
            
            <div class="grid">
                <!-- å³æ™‚ç›£æ§ -->
                <div class="section">
                    <h3>ğŸ“Š å³æ™‚ç›£æ§</h3>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="startMonitoring()">é–‹å§‹ç›£æ§</button>
                        <button class="btn btn-warning" onclick="stopMonitoring()">åœæ­¢ç›£æ§</button>
                    </div>
                    <div id="monitoring" class="output-box"></div>
                </div>
                
                <!-- æ¸¬è©¦å·¥å…· -->
                <div class="section">
                    <h3>ğŸ§ª æ¸¬è©¦å·¥å…·</h3>
                    <div class="button-group">
                        <button class="btn btn-success" onclick="insertTestContent()">æ’å…¥æ¸¬è©¦å…§å®¹</button>
                        <button class="btn btn-info" onclick="clearEditor()">æ¸…ç©ºç·¨è¼¯å™¨</button>
                    </div>
                    <div id="testTools" class="output-box"></div>
                </div>
            </div>
            
            <!-- ä½¿ç”¨èªªæ˜ -->
            <div class="info-box">
                <h4>ğŸ“‹ ä½¿ç”¨èªªæ˜</h4>
                <p><strong>å¦‚ä½•åœ¨ Bubble.io ä¸­ä½¿ç”¨ï¼š</strong></p>
                <ol>
                    <li>å°‡æ­¤ HTML ä»£ç¢¼æ”¾å…¥ Bubble.io çš„ <code>HTML Element</code> ä¸­</li>
                    <li>ç¢ºä¿æ‚¨çš„é é¢åŒ…å« TinyMCE Rich Text Editor</li>
                    <li>é»æ“Šå„ç¨®æŒ‰éˆ•ä¾†æª¢æ¸¬å’Œåˆ†æç·¨è¼¯å™¨ç‹€æ…‹</li>
                    <li>æŸ¥çœ‹è¼¸å‡ºçµæœä¾†é™¤éŒ¯å•é¡Œ</li>
                </ol>
            </div>
            
            <!-- JavaScript ä»£ç¢¼ -->
            <div class="section">
                <h3>âš™ï¸ å¦‚ä½•æ•´åˆåˆ° Bubble.io</h3>
                <div class="code-block">
&lt;!-- æ­¥é©Ÿ 1: åœ¨ Bubble Editor ä¸­æ·»åŠ  HTML Element --&gt;
&lt;!-- æ­¥é©Ÿ 2: å°‡æ­¤æ•´å€‹ HTML ä»£ç¢¼è²¼å…¥ HTML Element --&gt;
&lt;!-- æ­¥é©Ÿ 3: ç¢ºä¿é é¢åŒ…å« TinyMCE Rich Text Editor --&gt;
&lt;!-- æ­¥é©Ÿ 4: é è¦½é é¢ä¸¦ä½¿ç”¨é™¤éŒ¯å·¥å…· --&gt;
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let monitoringInterval = null;
        let currentEditor = null;
        
        // æ—¥èªŒå‡½æ•¸
        function log(message, elementId = 'basicDetection') {
            const element = document.getElementById(elementId);
            if (element) {
                const timestamp = new Date().toLocaleTimeString();
                element.textContent += `[${timestamp}] ${message}\n`;
                element.scrollTop = element.scrollHeight;
            }
            console.log(`[TinyMCE Debug] ${message}`);
        }
        
        // æ¸…é™¤æ—¥èªŒ
        function clearLog(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = '';
            }
        }
        
        // åŸºæœ¬æª¢æ¸¬å‡½æ•¸
        function detectTinyMCE() {
            clearLog('basicDetection');
            
            log('ğŸ” é–‹å§‹æª¢æ¸¬ TinyMCE...', 'basicDetection');
            
            // æª¢æŸ¥ TinyMCE æ˜¯å¦è¼‰å…¥
            if (typeof tinymce !== 'undefined') {
                log('âœ… TinyMCE å·²è¼‰å…¥', 'basicDetection');
                log(`ğŸ“¦ TinyMCE ç‰ˆæœ¬: ${tinymce.majorVersion}.${tinymce.minorVersion}`, 'basicDetection');
                log(`ğŸ”§ ç·¨è¼¯å™¨æ•¸é‡: ${tinymce.editors.length}`, 'basicDetection');
                
                if (tinymce.editors.length > 0) {
                    currentEditor = tinymce.editors[0];
                    log(`ğŸ¯ ç•¶å‰ç·¨è¼¯å™¨ ID: ${currentEditor.id}`, 'basicDetection');
                    log(`ğŸ“ ç·¨è¼¯å™¨æ¨¡å¼: ${currentEditor.mode.get()}`, 'basicDetection');
                } else {
                    log('âš ï¸ æ²’æœ‰æ‰¾åˆ°æ´»å‹•çš„ç·¨è¼¯å™¨', 'basicDetection');
                    log('ğŸ” æ­£åœ¨æœå°‹æœªåˆå§‹åŒ–çš„ç·¨è¼¯å™¨...', 'basicDetection');
                    
                    // å°‹æ‰¾ Bubble.io ç‰¹æœ‰çš„ç·¨è¼¯å™¨å…ƒç´ 
                    searchForBubbleEditors();
                }
            } else {
                log('âŒ TinyMCE æœªè¼‰å…¥', 'basicDetection');
                searchForBubbleEditors();
            }
        }
        
        // æœå°‹ Bubble.io ç·¨è¼¯å™¨
        function searchForBubbleEditors() {
            // æª¢æŸ¥ Bubble.io Rich Text Editor çš„å„ç¨®å¯èƒ½é¸æ“‡å™¨
            const selectors = [
                '[data-bubble-rich-text]',
                '.bubble-element.RichTextEditor',
                '.bubble-element[data-type="RichTextEditor"]',
                'textarea[data-type="rich"]',
                '.rich-text-editor',
                'div[contenteditable="true"]',
                'iframe[title*="Rich Text Area"]',
                'iframe[title*="rich text"]',
                '.mce-content-body',
                '#tinymce'
            ];
            
            let foundElements = [];
            
            selectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0) {
                    log(`ğŸ” æ‰¾åˆ° ${elements.length} å€‹å…ƒç´ : ${selector}`, 'basicDetection');
                    elements.forEach((el, index) => {
                        const info = {
                            element: el,
                            selector: selector,
                            id: el.id || 'no ID',
                            className: el.className || 'no class',
                            tagName: el.tagName,
                            contentEditable: el.contentEditable,
                            hasContent: el.innerHTML ? el.innerHTML.length > 0 : false
                        };
                        
                        foundElements.push(info);
                        log(`   - å…ƒä»¶ ${index + 1}: ${info.tagName} (ID: ${info.id}, Class: ${info.className.slice(0, 50)})`, 'basicDetection');
                        
                        if (info.contentEditable === 'true') {
                            log(`     âœ… å¯ç·¨è¼¯å…ƒç´ ï¼Œå…§å®¹é•·åº¦: ${el.innerHTML.length}`, 'basicDetection');
                        }
                    });
                }
            });
            
            // æª¢æŸ¥ iframe å…§çš„å…§å®¹
            const iframes = document.querySelectorAll('iframe');
            if (iframes.length > 0) {
                log(`ğŸ” æ‰¾åˆ° ${iframes.length} å€‹ iframeï¼Œæª¢æŸ¥å…§å®¹...`, 'basicDetection');
                iframes.forEach((iframe, index) => {
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            const editableContent = iframeDoc.querySelector('[contenteditable="true"], .mce-content-body');
                            if (editableContent) {
                                log(`   âœ… iframe ${index + 1} åŒ…å«å¯ç·¨è¼¯å…§å®¹`, 'basicDetection');
                                log(`     - å…§å®¹é•·åº¦: ${editableContent.innerHTML.length}`, 'basicDetection');
                                
                                // å˜—è©¦è¨­ç½®ç‚ºç•¶å‰ç·¨è¼¯å™¨
                                window.currentIframeEditor = {
                                    iframe: iframe,
                                    document: iframeDoc,
                                    content: editableContent
                                };
                            }
                        }
                    } catch (e) {
                        log(`   âš ï¸ iframe ${index + 1} ç„¡æ³•è¨ªå• (è·¨åŸŸé™åˆ¶)`, 'basicDetection');
                    }
                });
            }
            
            // å˜—è©¦å¼·åˆ¶åˆå§‹åŒ– TinyMCE
            if (typeof tinymce !== 'undefined' && foundElements.length > 0) {
                log('ğŸ”§ å˜—è©¦æ‰‹å‹•åˆå§‹åŒ–ç·¨è¼¯å™¨...', 'basicDetection');
                setTimeout(() => {
                    checkForNewEditors();
                }, 2000);
            }
            
            return foundElements;
        }
        
        // æª¢æŸ¥æ–°ç·¨è¼¯å™¨
        function checkForNewEditors() {
            if (typeof tinymce !== 'undefined') {
                log(`ğŸ”„ é‡æ–°æª¢æŸ¥ï¼Œç¾åœ¨æœ‰ ${tinymce.editors.length} å€‹ç·¨è¼¯å™¨`, 'basicDetection');
                if (tinymce.editors.length > 0 && !currentEditor) {
                    currentEditor = tinymce.editors[0];
                    log(`ğŸ¯ æ‰¾åˆ°æ–°ç·¨è¼¯å™¨: ${currentEditor.id}`, 'basicDetection');
                }
            }
        }
        
        // åˆ—å‡ºæ‰€æœ‰ç·¨è¼¯å™¨
        function listAllEditors() {
            clearLog('basicDetection');
            
            if (typeof tinymce !== 'undefined' && tinymce.editors.length > 0) {
                log('ğŸ“‹ æ‰€æœ‰ TinyMCE ç·¨è¼¯å™¨:', 'basicDetection');
                
                tinymce.editors.forEach((editor, index) => {
                    log(`\nç·¨è¼¯å™¨ ${index + 1}:`, 'basicDetection');
                    log(`  ID: ${editor.id}`, 'basicDetection');
                    log(`  å®¹å™¨: ${editor.getContainer().id}`, 'basicDetection');
                    log(`  æ¨¡å¼: ${editor.mode.get()}`, 'basicDetection');
                    log(`  æ˜¯å¦åˆå§‹åŒ–: ${editor.initialized}`, 'basicDetection');
                    log(`  å…§å®¹é•·åº¦: ${editor.getContent().length} å­—å…ƒ`, 'basicDetection');
                });
            } else {
                log('âŒ æ²’æœ‰æ‰¾åˆ° TinyMCE ç·¨è¼¯å™¨', 'basicDetection');
                
                // å˜—è©¦æŸ¥æ‰¾å…¶ä»–å¯èƒ½çš„ç·¨è¼¯å™¨
                const editableElements = document.querySelectorAll('[contenteditable="true"]');
                if (editableElements.length > 0) {
                    log(`ğŸ” æ‰¾åˆ° ${editableElements.length} å€‹å¯ç·¨è¼¯å…ƒç´ :`, 'basicDetection');
                    editableElements.forEach((el, index) => {
                        log(`  å…ƒç´  ${index + 1}: ${el.tagName} (ID: ${el.id || 'no ID'})`, 'basicDetection');
                        log(`    å…§å®¹é•·åº¦: ${el.textContent.length} å­—å…ƒ`, 'basicDetection');
                    });
                }
            }
        }
        
        // ç²å–ç·¨è¼¯å™¨å…§å®¹
        function getEditorContent() {
            clearLog('basicDetection');
            
            if (currentEditor) {
                const content = currentEditor.getContent();
                const textContent = currentEditor.getContent({format: 'text'});
                
                log('ğŸ“ TinyMCE ç·¨è¼¯å™¨å…§å®¹ (HTML):', 'basicDetection');
                log(content, 'basicDetection');
                log('\nğŸ“ ç·¨è¼¯å™¨å…§å®¹ (ç´”æ–‡å­—):', 'basicDetection');
                log(textContent, 'basicDetection');
                log(`\nğŸ“Š çµ±è¨ˆ: HTML ${content.length} å­—å…ƒ, ç´”æ–‡å­— ${textContent.length} å­—å…ƒ`, 'basicDetection');
                
            } else if (window.currentIframeEditor) {
                log('ğŸ“ å¾ iframe ç·¨è¼¯å™¨ç²å–å…§å®¹:', 'basicDetection');
                const content = window.currentIframeEditor.content.innerHTML;
                const textContent = window.currentIframeEditor.content.textContent;
                
                log('HTML å…§å®¹:', 'basicDetection');
                log(content, 'basicDetection');
                log('\nç´”æ–‡å­—å…§å®¹:', 'basicDetection');
                log(textContent, 'basicDetection');
                log(`\nğŸ“Š çµ±è¨ˆ: HTML ${content.length} å­—å…ƒ, ç´”æ–‡å­— ${textContent.length} å­—å…ƒ`, 'basicDetection');
                
            } else {
                log('âŒ æ²’æœ‰æ´»å‹•çš„ç·¨è¼¯å™¨', 'basicDetection');
                
                // å˜—è©¦å¾å…¶ä»–å…ƒç´ ç²å–å…§å®¹
                const editableElements = document.querySelectorAll('[contenteditable="true"]');
                if (editableElements.length > 0) {
                    log('ğŸ” å¾å¯ç·¨è¼¯å…ƒç´ ç²å–å…§å®¹:', 'basicDetection');
                    editableElements.forEach((el, index) => {
                        log(`\nå…ƒç´  ${index + 1} (${el.tagName})å…§å®¹:`, 'basicDetection');
                        log(`HTML é•·åº¦: ${el.innerHTML.length}`, 'basicDetection');
                        log(`æ–‡å­—é•·åº¦: ${el.textContent.length}`, 'basicDetection');
                        if (el.innerHTML.length < 1000) {
                            log('HTML å…§å®¹:', 'basicDetection');
                            log(el.innerHTML, 'basicDetection');
                        } else {
                            log('HTML å…§å®¹ (å‰ 500 å­—å…ƒ):', 'basicDetection');
                            log(el.innerHTML.substring(0, 500) + '...', 'basicDetection');
                        }
                    });
                } else {
                    log('ğŸ” å˜—è©¦æœå°‹å…¶ä»–å¯èƒ½çš„å…§å®¹å€åŸŸ...', 'basicDetection');
                    
                    // æª¢æŸ¥ textarea
                    const textareas = document.querySelectorAll('textarea');
                    if (textareas.length > 0) {
                        log(`æ‰¾åˆ° ${textareas.length} å€‹ textarea:`, 'basicDetection');
                        textareas.forEach((textarea, index) => {
                            log(`textarea ${index + 1}: ${textarea.value.length} å­—å…ƒ`, 'basicDetection');
                            if (textarea.value.length < 500) {
                                log(textarea.value, 'basicDetection');
                            }
                        });
                    }
                }
            }
        }
        
        // ç²å– HTML åŸå§‹ç¢¼
        function getEditorHTML() {
            clearLog('basicDetection');
            
            if (currentEditor) {
                const html = currentEditor.getContent();
                log('ğŸ” HTML åŸå§‹ç¢¼åˆ†æ:', 'basicDetection');
                log(html, 'basicDetection');
                
                // åˆ†æ HTML çµæ§‹
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                
                log('\nğŸ·ï¸ HTML æ¨™ç±¤çµ±è¨ˆ:', 'basicDetection');
                const tags = {};
                tempDiv.querySelectorAll('*').forEach(el => {
                    const tagName = el.tagName.toLowerCase();
                    tags[tagName] = (tags[tagName] || 0) + 1;
                });
                
                Object.entries(tags).forEach(([tag, count]) => {
                    log(`  ${tag}: ${count}`, 'basicDetection');
                });
                
            } else {
                log('âŒ æ²’æœ‰æ´»å‹•çš„ç·¨è¼¯å™¨', 'basicDetection');
                
                // å˜—è©¦å¾ iframe ç²å–å…§å®¹
                if (window.currentIframeEditor) {
                    log('ğŸ” å˜—è©¦å¾ iframe ç·¨è¼¯å™¨ç²å–å…§å®¹...', 'basicDetection');
                    const content = window.currentIframeEditor.content.innerHTML;
                    log('iframe å…§å®¹:', 'basicDetection');
                    log(content, 'basicDetection');
                }
            }
        }
        
        // å¼·åˆ¶åˆå§‹åŒ–ç·¨è¼¯å™¨
        function forceInitEditor() {
            clearLog('basicDetection');
            log('ğŸ”§ å˜—è©¦å¼·åˆ¶åˆå§‹åŒ– TinyMCE ç·¨è¼¯å™¨...', 'basicDetection');
            
            if (typeof tinymce !== 'undefined') {
                // æŸ¥æ‰¾å¯èƒ½çš„ç·¨è¼¯å™¨ç›®æ¨™
                const targets = document.querySelectorAll('textarea, [contenteditable="true"]');
                log(`ğŸ” æ‰¾åˆ° ${targets.length} å€‹å¯èƒ½çš„ç›®æ¨™å…ƒç´ `, 'basicDetection');
                
                targets.forEach((target, index) => {
                    if (!target.id) {
                        target.id = `tinymce-target-${index}`;
                        log(`è¨­ç½® ID: ${target.id}`, 'basicDetection');
                    }
                    
                    // å˜—è©¦åˆå§‹åŒ–
                    try {
                        tinymce.init({
                            target: target,
                            plugins: 'advlist autolink lists link image charmap print preview anchor searchreplace visualblocks code fullscreen insertdatetime media table paste code help wordcount',
                            toolbar: 'undo redo | formatselect | bold italic backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | removeformat | help',
                            setup: function(editor) {
                                editor.on('init', function() {
                                    log(`âœ… ç·¨è¼¯å™¨åˆå§‹åŒ–æˆåŠŸ: ${editor.id}`, 'basicDetection');
                                    currentEditor = editor;
                                });
                            }
                        });
                    } catch (error) {
                        log(`âŒ åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'basicDetection');
                    }
                });
                
                // ç­‰å¾…åˆå§‹åŒ–å®Œæˆ
                setTimeout(() => {
                    log(`ğŸ”„ åˆå§‹åŒ–å¾Œç·¨è¼¯å™¨æ•¸é‡: ${tinymce.editors.length}`, 'basicDetection');
                }, 3000);
                
            } else {
                log('âŒ TinyMCE æœªè¼‰å…¥ï¼Œç„¡æ³•åˆå§‹åŒ–', 'basicDetection');
            }
        }
        
        // æª¢æŸ¥ iframe å…§å®¹
        function getIframeContent() {
            clearLog('basicDetection');
            log('ğŸ” æª¢æŸ¥æ‰€æœ‰ iframe å…§å®¹...', 'basicDetection');
            
            const iframes = document.querySelectorAll('iframe');
            log(`æ‰¾åˆ° ${iframes.length} å€‹ iframe`, 'basicDetection');
            
            iframes.forEach((iframe, index) => {
                log(`\n--- iframe ${index + 1} ---`, 'basicDetection');
                log(`ID: ${iframe.id || 'no ID'}`, 'basicDetection');
                log(`Title: ${iframe.title || 'no title'}`, 'basicDetection');
                log(`Src: ${iframe.src || 'no src'}`, 'basicDetection');
                log(`ClassName: ${iframe.className || 'no class'}`, 'basicDetection');
                
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc) {
                        const body = iframeDoc.body;
                        if (body) {
                            log(`Body HTML é•·åº¦: ${body.innerHTML.length}`, 'basicDetection');
                            log(`Body æ–‡å­—é•·åº¦: ${body.textContent.length}`, 'basicDetection');
                            
                            // æŸ¥æ‰¾å¯ç·¨è¼¯å…§å®¹
                            const editableElements = iframeDoc.querySelectorAll('[contenteditable="true"], .mce-content-body');
                            if (editableElements.length > 0) {
                                log(`âœ… æ‰¾åˆ° ${editableElements.length} å€‹å¯ç·¨è¼¯å…ƒç´ `, 'basicDetection');
                                editableElements.forEach((el, i) => {
                                    log(`  å…ƒç´  ${i + 1}: ${el.tagName}, å…§å®¹é•·åº¦: ${el.innerHTML.length}`, 'basicDetection');
                                    
                                    // å¦‚æœå…§å®¹å¾ˆçŸ­ï¼Œç›´æ¥é¡¯ç¤º
                                    if (el.innerHTML.length < 500) {
                                        log(`  å…§å®¹: ${el.innerHTML}`, 'basicDetection');
                                    }
                                });
                                
                                // è¨­ç½®ç‚ºç•¶å‰ iframe ç·¨è¼¯å™¨
                                window.currentIframeEditor = {
                                    iframe: iframe,
                                    document: iframeDoc,
                                    content: editableElements[0]
                                };
                                log(`âœ… å·²è¨­ç½®ç‚ºç•¶å‰ iframe ç·¨è¼¯å™¨`, 'basicDetection');
                            }
                            
                            // æª¢æŸ¥æ˜¯å¦æœ‰ TinyMCE ç›¸é—œå…ƒç´ 
                            const tinyElements = iframeDoc.querySelectorAll('[id*="mce"], [class*="mce"], [id*="tinymce"]');
                            if (tinyElements.length > 0) {
                                log(`ğŸ” æ‰¾åˆ° ${tinyElements.length} å€‹ TinyMCE ç›¸é—œå…ƒç´ `, 'basicDetection');
                            }
                        }
                    } else {
                        log('âŒ ç„¡æ³•è¨ªå• iframe document', 'basicDetection');
                    }
                } catch (error) {
                    log(`âŒ è¨ªå• iframe æ™‚å‡ºéŒ¯: ${error.message}`, 'basicDetection');
                }
            });
            
            if (iframes.length === 0) {
                log('â„¹ï¸ æ²’æœ‰æ‰¾åˆ° iframe å…ƒç´ ', 'basicDetection');
            }
        }
        
        // åˆ†æå…§å®¹çµæ§‹
        function analyzeContent() {
            clearLog('contentAnalysis');
            
            let content = '';
            if (currentEditor) {
                content = currentEditor.getContent();
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    content = editableEl.innerHTML;
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å…§å®¹', 'contentAnalysis');
                    return;
                }
            }
            
            log('ğŸ“Š å…§å®¹çµæ§‹åˆ†æ:', 'contentAnalysis');
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            // åŸºæœ¬çµ±è¨ˆ
            log(`ç¸½å­—å…ƒæ•¸: ${content.length}`, 'contentAnalysis');
            log(`ç´”æ–‡å­—å­—å…ƒæ•¸: ${tempDiv.textContent.length}`, 'contentAnalysis');
            log(`HTML å…ƒç´ æ•¸: ${tempDiv.querySelectorAll('*').length}`, 'contentAnalysis');
            
            // æ®µè½å’Œæ¨™é¡Œåˆ†æ
            const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');
            const paragraphs = tempDiv.querySelectorAll('p');
            const lists = tempDiv.querySelectorAll('ul, ol');
            const listItems = tempDiv.querySelectorAll('li');
            
            log(`\nğŸ“‹ çµæ§‹å…ƒç´ :`, 'contentAnalysis');
            log(`  æ¨™é¡Œ (h1-h6): ${headings.length}`, 'contentAnalysis');
            log(`  æ®µè½ (p): ${paragraphs.length}`, 'contentAnalysis');
            log(`  åˆ—è¡¨ (ul/ol): ${lists.length}`, 'contentAnalysis');
            log(`  åˆ—è¡¨é …ç›® (li): ${listItems.length}`, 'contentAnalysis');
            
            // æ¨£å¼åˆ†æ
            const styledElements = tempDiv.querySelectorAll('[class], [style]');
            log(`\nğŸ¨ æ¨£å¼å…ƒç´ : ${styledElements.length}`, 'contentAnalysis');
            
            // é€£çµå’Œåœ–ç‰‡
            const links = tempDiv.querySelectorAll('a');
            const images = tempDiv.querySelectorAll('img');
            log(`\nğŸ”— åª’é«”å…ƒç´ :`, 'contentAnalysis');
            log(`  é€£çµ (a): ${links.length}`, 'contentAnalysis');
            log(`  åœ–ç‰‡ (img): ${images.length}`, 'contentAnalysis');
        }
        
        // æŸ¥æ‰¾è¦–è¦ºæ¨™è¨˜
        function findMarkers() {
            clearLog('contentAnalysis');
            
            let content = '';
            if (currentEditor) {
                content = currentEditor.getContent();
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    content = editableEl.innerHTML;
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å…§å®¹', 'contentAnalysis');
                    return;
                }
            }
            
            log('ğŸ·ï¸ æœå°‹è¦–è¦ºæ¨™è¨˜:', 'contentAnalysis');
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            // æŸ¥æ‰¾å„ç¨®æ¨™è¨˜
            const markers = {
                'opt-new': tempDiv.querySelectorAll('.opt-new'),
                'opt-modified': tempDiv.querySelectorAll('.opt-modified'),
                'opt-placeholder': tempDiv.querySelectorAll('.opt-placeholder'),
                'opt-keyword': tempDiv.querySelectorAll('.opt-keyword'),
                'opt-keyword-existing': tempDiv.querySelectorAll('.opt-keyword-existing'),
                'opt-strength': tempDiv.querySelectorAll('.opt-strength')
            };
            
            let totalMarkers = 0;
            Object.entries(markers).forEach(([className, elements]) => {
                log(`  ${className}: ${elements.length}`, 'contentAnalysis');
                totalMarkers += elements.length;
                
                if (elements.length > 0) {
                    elements.forEach((el, index) => {
                        log(`    ${index + 1}. "${el.textContent.slice(0, 50)}..."`, 'contentAnalysis');
                    });
                }
            });
            
            log(`\nğŸ“Š ç¸½æ¨™è¨˜æ•¸: ${totalMarkers}`, 'contentAnalysis');
            
            // æª¢æŸ¥ä½”ä½ç¬¦
            const placeholderPattern = /\[([A-Z_\s]+)\]/g;
            const placeholders = content.match(placeholderPattern) || [];
            log(`ğŸ” ä½”ä½ç¬¦: ${placeholders.length}`, 'contentAnalysis');
            placeholders.forEach(placeholder => {
                log(`  - ${placeholder}`, 'contentAnalysis');
            });
        }
        
        // çµ±è¨ˆå…ƒç´ 
        function countElements() {
            clearLog('contentAnalysis');
            
            let content = '';
            if (currentEditor) {
                content = currentEditor.getContent();
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    content = editableEl.innerHTML;
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å…§å®¹', 'contentAnalysis');
                    return;
                }
            }
            
            log('ğŸ”¢ å…ƒç´ çµ±è¨ˆ:', 'contentAnalysis');
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            // çµ±è¨ˆæ‰€æœ‰æ¨™ç±¤
            const tagCounts = {};
            tempDiv.querySelectorAll('*').forEach(el => {
                const tagName = el.tagName.toLowerCase();
                tagCounts[tagName] = (tagCounts[tagName] || 0) + 1;
            });
            
            log('ğŸ“‹ HTML æ¨™ç±¤çµ±è¨ˆ:', 'contentAnalysis');
            Object.entries(tagCounts)
                .sort(([,a], [,b]) => b - a)
                .forEach(([tag, count]) => {
                    log(`  ${tag}: ${count}`, 'contentAnalysis');
                });
            
            // çµ±è¨ˆ class å±¬æ€§
            const classCounts = {};
            tempDiv.querySelectorAll('[class]').forEach(el => {
                el.classList.forEach(className => {
                    classCounts[className] = (classCounts[className] || 0) + 1;
                });
            });
            
            if (Object.keys(classCounts).length > 0) {
                log('\nğŸ¨ CSS Class çµ±è¨ˆ:', 'contentAnalysis');
                Object.entries(classCounts)
                    .sort(([,a], [,b]) => b - a)
                    .forEach(([className, count]) => {
                        log(`  ${className}: ${count}`, 'contentAnalysis');
                    });
            }
        }
        
        // é©—è­‰ HTML
        function validateHTML() {
            clearLog('contentAnalysis');
            
            let content = '';
            if (currentEditor) {
                content = currentEditor.getContent();
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    content = editableEl.innerHTML;
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å…§å®¹', 'contentAnalysis');
                    return;
                }
            }
            
            log('âœ… HTML é©—è­‰:', 'contentAnalysis');
            
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                
                // æª¢æŸ¥æ˜¯å¦æœ‰è§£æéŒ¯èª¤
                if (tempDiv.innerHTML === content) {
                    log('âœ… HTML æ ¼å¼æ­£ç¢º', 'contentAnalysis');
                } else {
                    log('âš ï¸ HTML å¯èƒ½æœ‰æ ¼å¼å•é¡Œ', 'contentAnalysis');
                }
                
                // æª¢æŸ¥å¸¸è¦‹å•é¡Œ
                const issues = [];
                
                // æª¢æŸ¥æœªé—œé–‰çš„æ¨™ç±¤
                const openTags = content.match(/<[^/>][^>]*>/g) || [];
                const closeTags = content.match(/<\/[^>]*>/g) || [];
                if (openTags.length !== closeTags.length) {
                    issues.push(`æ¨™ç±¤ä¸åŒ¹é…: ${openTags.length} å€‹é–‹å•Ÿæ¨™ç±¤, ${closeTags.length} å€‹é—œé–‰æ¨™ç±¤`);
                }
                
                // æª¢æŸ¥ç©ºçš„ class å±¬æ€§
                if (content.includes('class=""')) {
                    issues.push('ç™¼ç¾ç©ºçš„ class å±¬æ€§');
                }
                
                // æª¢æŸ¥ç„¡æ•ˆå­—å…ƒ
                if (content.includes('&nbsp;&nbsp;&nbsp;')) {
                    issues.push('ç™¼ç¾å¤šå€‹é€£çºŒçš„ &nbsp;');
                }
                
                if (issues.length > 0) {
                    log('\nâš ï¸ ç™¼ç¾çš„å•é¡Œ:', 'contentAnalysis');
                    issues.forEach(issue => {
                        log(`  - ${issue}`, 'contentAnalysis');
                    });
                } else {
                    log('âœ… æ²’æœ‰ç™¼ç¾æ˜é¡¯å•é¡Œ', 'contentAnalysis');
                }
                
            } catch (error) {
                log(`âŒ HTML é©—è­‰éŒ¯èª¤: ${error.message}`, 'contentAnalysis');
            }
        }
        
        // é–‹å§‹ç›£æ§
        function startMonitoring() {
            clearLog('monitoring');
            log('ğŸ”„ é–‹å§‹å³æ™‚ç›£æ§...', 'monitoring');
            
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
            
            monitoringInterval = setInterval(() => {
                const timestamp = new Date().toLocaleTimeString();
                
                if (currentEditor) {
                    const content = currentEditor.getContent();
                    const textLength = currentEditor.getContent({format: 'text'}).length;
                    log(`[${timestamp}] å…§å®¹é•·åº¦: ${content.length} HTML, ${textLength} æ–‡å­—`, 'monitoring');
                } else {
                    // æª¢æŸ¥æ˜¯å¦æœ‰æ–°çš„ç·¨è¼¯å™¨
                    if (typeof tinymce !== 'undefined' && tinymce.editors.length > 0) {
                        currentEditor = tinymce.editors[0];
                        log(`[${timestamp}] ç™¼ç¾æ–°ç·¨è¼¯å™¨: ${currentEditor.id}`, 'monitoring');
                    } else {
                        log(`[${timestamp}] æ²’æœ‰æ´»å‹•ç·¨è¼¯å™¨`, 'monitoring');
                    }
                }
            }, 2000);
        }
        
        // åœæ­¢ç›£æ§
        function stopMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                log('â¹ï¸ ç›£æ§å·²åœæ­¢', 'monitoring');
            }
        }
        
        // æ’å…¥æ¸¬è©¦å…§å®¹
        function insertTestContent() {
            clearLog('testTools');
            
            const testHTML = `
                <h1>æ¸¬è©¦å±¥æ­·</h1>
                <p class="opt-new">é€™æ˜¯ä¸€å€‹ <span class="opt-keyword">æ–°å¢çš„æ®µè½</span>ï¼ŒåŒ…å« <span class="opt-placeholder">[PERCENTAGE]</span> ä½”ä½ç¬¦ã€‚</p>
                <ul>
                    <li class="opt-modified">ä¿®æ”¹éçš„ <span class="opt-keyword-existing">é …ç›®</span></li>
                    <li>æ™®é€šé …ç›®with <span class="opt-strength">å¼·èª¿å…§å®¹</span></li>
                </ul>
            `;
            
            if (currentEditor) {
                currentEditor.setContent(testHTML);
                log('âœ… æ¸¬è©¦å…§å®¹å·²æ’å…¥åˆ° TinyMCE ç·¨è¼¯å™¨', 'testTools');
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    editableEl.innerHTML = testHTML;
                    log('âœ… æ¸¬è©¦å…§å®¹å·²æ’å…¥åˆ°å¯ç·¨è¼¯å…ƒç´ ', 'testTools');
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å¯ç·¨è¼¯çš„å…ƒç´ ', 'testTools');
                }
            }
        }
        
        // æ¸…ç©ºç·¨è¼¯å™¨
        function clearEditor() {
            clearLog('testTools');
            
            if (currentEditor) {
                currentEditor.setContent('');
                log('ğŸ§¹ TinyMCE ç·¨è¼¯å™¨å·²æ¸…ç©º', 'testTools');
            } else {
                const editableEl = document.querySelector('[contenteditable="true"]');
                if (editableEl) {
                    editableEl.innerHTML = '';
                    log('ğŸ§¹ å¯ç·¨è¼¯å…ƒç´ å·²æ¸…ç©º', 'testTools');
                } else {
                    log('âŒ æ²’æœ‰æ‰¾åˆ°å¯ç·¨è¼¯çš„å…ƒç´ ', 'testTools');
                }
            }
        }
        
        // é é¢è¼‰å…¥æ™‚è‡ªå‹•æª¢æ¸¬
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                detectTinyMCE();
            }, 1000);
        });
        
        // å®šæœŸæª¢æŸ¥ TinyMCE æ˜¯å¦è¼‰å…¥
        const checkInterval = setInterval(() => {
            if (typeof tinymce !== 'undefined' && tinymce.editors.length > 0 && !currentEditor) {
                currentEditor = tinymce.editors[0];
                clearInterval(checkInterval);
                log('ğŸ¯ è‡ªå‹•åµæ¸¬åˆ° TinyMCE ç·¨è¼¯å™¨', 'basicDetection');
            }
        }, 1000);
        
        // æ¸…é™¤æª¢æŸ¥é–“éš”ï¼ˆ10ç§’å¾Œåœæ­¢ï¼‰
        setTimeout(() => {
            clearInterval(checkInterval);
        }, 10000);
    </script>
</body>
</html>